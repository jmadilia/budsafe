// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
)

type BusinessFilter struct {
	Type   *BusinessType `json:"type,omitempty"`
	State  *string       `json:"state,omitempty"`
	Search *string       `json:"search,omitempty"`
}

type CreateBusinessInput struct {
	Name        string       `json:"name"`
	Type        BusinessType `json:"type"`
	Description *string      `json:"description,omitempty"`
}

type CreateComplianceCheckInput struct {
	LicenseID    string           `json:"licenseId"`
	Title        string           `json:"title"`
	DueDate      string           `json:"dueDate"`
	Status       ComplianceStatus `json:"status"`
	AssignedToID *string          `json:"assignedToId,omitempty"`
	Notes        *string          `json:"notes,omitempty"`
}

type CreateDocumentInput struct {
	Name                 string  `json:"name"`
	Description          *string `json:"description,omitempty"`
	FileURL              string  `json:"fileUrl"`
	FileType             string  `json:"fileType"`
	LicenseID            *string `json:"licenseId,omitempty"`
	RenewalRequirementID *string `json:"renewalRequirementId,omitempty"`
}

type CreateLicenseInput struct {
	BusinessID     string        `json:"businessId"`
	LocationID     *string       `json:"locationId,omitempty"`
	LicenseNumber  string        `json:"licenseNumber"`
	LicenseType    LicenseType   `json:"licenseType"`
	JurisdictionID string        `json:"jurisdictionId"`
	IssuedDate     string        `json:"issuedDate"`
	ExpirationDate string        `json:"expirationDate"`
	Status         LicenseStatus `json:"status"`
	Notes          *string       `json:"notes,omitempty"`
}

type CreateLocationInput struct {
	BusinessID string `json:"businessId"`
	Address    string `json:"address"`
	City       string `json:"city"`
	State      string `json:"state"`
	ZipCode    string `json:"zipCode"`
	IsPrimary  bool   `json:"isPrimary"`
}

type CreateRenewalRequirementInput struct {
	LicenseID   string  `json:"licenseId"`
	Description string  `json:"description"`
	Deadline    *string `json:"deadline,omitempty"`
	IsCompleted bool    `json:"isCompleted"`
}

type DashboardSummary struct {
	BusinessID          string          `json:"businessId"`
	ActiveLicenses      int             `json:"activeLicenses"`
	ExpiringLicenses    int             `json:"expiringLicenses"`
	ComplianceIssues    int             `json:"complianceIssues"`
	UpcomingRenewals    int             `json:"upcomingRenewals"`
	RecentNotifications []*Notification `json:"recentNotifications"`
}

// Document attached to a license or renewal requirement
type Document struct {
	ID                   string              `json:"id"`
	Name                 string              `json:"name"`
	Description          *string             `json:"description,omitempty"`
	FileURL              string              `json:"fileUrl"`
	FileType             string              `json:"fileType"`
	UploadedBy           *User               `json:"uploadedBy"`
	LicenseID            *string             `json:"licenseId,omitempty"`
	License              *License            `json:"license,omitempty"`
	RenewalRequirementID *string             `json:"renewalRequirementId,omitempty"`
	RenewalRequirement   *RenewalRequirement `json:"renewalRequirement,omitempty"`
	CreatedAt            string              `json:"createdAt"`
	UpdatedAt            *string             `json:"updatedAt,omitempty"`
}

// Physical location of a business
type Location struct {
	ID         string     `json:"id"`
	BusinessID string     `json:"businessId"`
	Business   *Business  `json:"business"`
	Address    string     `json:"address"`
	City       string     `json:"city"`
	State      string     `json:"state"`
	ZipCode    string     `json:"zipCode"`
	IsPrimary  bool       `json:"isPrimary"`
	Licenses   []*License `json:"licenses,omitempty"`
	CreatedAt  string     `json:"createdAt"`
	UpdatedAt  *string    `json:"updatedAt,omitempty"`
}

type Mutation struct {
}

type Query struct {
}

// Specific regulation within a jurisdiction
type Regulation struct {
	ID               string             `json:"id"`
	JurisdictionID   string             `json:"jurisdictionId"`
	Jurisdiction     *Jurisdiction      `json:"jurisdiction"`
	Title            string             `json:"title"`
	Description      string             `json:"description"`
	Category         RegulationCategory `json:"category"`
	EffectiveDate    string             `json:"effectiveDate"`
	Requirements     map[string]any     `json:"requirements,omitempty"`
	DocumentationURL *string            `json:"documentationUrl,omitempty"`
	CreatedAt        string             `json:"createdAt"`
	UpdatedAt        *string            `json:"updatedAt,omitempty"`
}

// Requirements for license renewal
type RenewalRequirement struct {
	ID          string      `json:"id"`
	LicenseID   string      `json:"licenseId"`
	License     *License    `json:"license"`
	Description string      `json:"description"`
	Deadline    *string     `json:"deadline,omitempty"`
	IsCompleted bool        `json:"isCompleted"`
	Documents   []*Document `json:"documents,omitempty"`
	CreatedAt   string      `json:"createdAt"`
	UpdatedAt   *string     `json:"updatedAt,omitempty"`
}

type Subscription struct {
}

type UpdateBusinessInput struct {
	Name        *string       `json:"name,omitempty"`
	Type        *BusinessType `json:"type,omitempty"`
	Description *string       `json:"description,omitempty"`
}

type UpdateComplianceCheckInput struct {
	Title        *string           `json:"title,omitempty"`
	DueDate      *string           `json:"dueDate,omitempty"`
	Status       *ComplianceStatus `json:"status,omitempty"`
	AssignedToID *string           `json:"assignedToId,omitempty"`
	Notes        *string           `json:"notes,omitempty"`
}

type UpdateLicenseInput struct {
	LocationID     *string        `json:"locationId,omitempty"`
	LicenseNumber  *string        `json:"licenseNumber,omitempty"`
	LicenseType    *LicenseType   `json:"licenseType,omitempty"`
	JurisdictionID *string        `json:"jurisdictionId,omitempty"`
	IssuedDate     *string        `json:"issuedDate,omitempty"`
	ExpirationDate *string        `json:"expirationDate,omitempty"`
	Status         *LicenseStatus `json:"status,omitempty"`
	Notes          *string        `json:"notes,omitempty"`
}

type UpdateLocationInput struct {
	Address   *string `json:"address,omitempty"`
	City      *string `json:"city,omitempty"`
	State     *string `json:"state,omitempty"`
	ZipCode   *string `json:"zipCode,omitempty"`
	IsPrimary *bool   `json:"isPrimary,omitempty"`
}

type UpdateRenewalRequirementInput struct {
	Description *string `json:"description,omitempty"`
	Deadline    *string `json:"deadline,omitempty"`
	IsCompleted *bool   `json:"isCompleted,omitempty"`
}

type UpdateUserInput struct {
	Email     *string   `json:"email,omitempty"`
	FirstName *string   `json:"firstName,omitempty"`
	LastName  *string   `json:"lastName,omitempty"`
	Role      *UserRole `json:"role,omitempty"`
}

type BusinessType string

const (
	BusinessTypeCultivator  BusinessType = "CULTIVATOR"
	BusinessTypeProcessor   BusinessType = "PROCESSOR"
	BusinessTypeDistributor BusinessType = "DISTRIBUTOR"
	BusinessTypeRetailer    BusinessType = "RETAILER"
	BusinessTypeTestingLab  BusinessType = "TESTING_LAB"
	BusinessTypeDelivery    BusinessType = "DELIVERY"
	BusinessTypeIntegrated  BusinessType = "INTEGRATED"
)

var AllBusinessType = []BusinessType{
	BusinessTypeCultivator,
	BusinessTypeProcessor,
	BusinessTypeDistributor,
	BusinessTypeRetailer,
	BusinessTypeTestingLab,
	BusinessTypeDelivery,
	BusinessTypeIntegrated,
}

func (e BusinessType) IsValid() bool {
	switch e {
	case BusinessTypeCultivator, BusinessTypeProcessor, BusinessTypeDistributor, BusinessTypeRetailer, BusinessTypeTestingLab, BusinessTypeDelivery, BusinessTypeIntegrated:
		return true
	}
	return false
}

func (e BusinessType) String() string {
	return string(e)
}

func (e *BusinessType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BusinessType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BusinessType", str)
	}
	return nil
}

func (e BusinessType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BusinessType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BusinessType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ComplianceStatus string

const (
	ComplianceStatusCompliant      ComplianceStatus = "COMPLIANT"
	ComplianceStatusNonCompliant   ComplianceStatus = "NON_COMPLIANT"
	ComplianceStatusPendingReview  ComplianceStatus = "PENDING_REVIEW"
	ComplianceStatusNeedsAttention ComplianceStatus = "NEEDS_ATTENTION"
	ComplianceStatusNotApplicable  ComplianceStatus = "NOT_APPLICABLE"
)

var AllComplianceStatus = []ComplianceStatus{
	ComplianceStatusCompliant,
	ComplianceStatusNonCompliant,
	ComplianceStatusPendingReview,
	ComplianceStatusNeedsAttention,
	ComplianceStatusNotApplicable,
}

func (e ComplianceStatus) IsValid() bool {
	switch e {
	case ComplianceStatusCompliant, ComplianceStatusNonCompliant, ComplianceStatusPendingReview, ComplianceStatusNeedsAttention, ComplianceStatusNotApplicable:
		return true
	}
	return false
}

func (e ComplianceStatus) String() string {
	return string(e)
}

func (e *ComplianceStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ComplianceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ComplianceStatus", str)
	}
	return nil
}

func (e ComplianceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ComplianceStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ComplianceStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type JurisdictionType string

const (
	JurisdictionTypeUsState          JurisdictionType = "US_STATE"
	JurisdictionTypeCanadianProvince JurisdictionType = "CANADIAN_PROVINCE"
	JurisdictionTypeCountry          JurisdictionType = "COUNTRY"
)

var AllJurisdictionType = []JurisdictionType{
	JurisdictionTypeUsState,
	JurisdictionTypeCanadianProvince,
	JurisdictionTypeCountry,
}

func (e JurisdictionType) IsValid() bool {
	switch e {
	case JurisdictionTypeUsState, JurisdictionTypeCanadianProvince, JurisdictionTypeCountry:
		return true
	}
	return false
}

func (e JurisdictionType) String() string {
	return string(e)
}

func (e *JurisdictionType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JurisdictionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JurisdictionType", str)
	}
	return nil
}

func (e JurisdictionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *JurisdictionType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e JurisdictionType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type LicenseStatus string

const (
	LicenseStatusActive            LicenseStatus = "ACTIVE"
	LicenseStatusPending           LicenseStatus = "PENDING"
	LicenseStatusExpired           LicenseStatus = "EXPIRED"
	LicenseStatusRevoked           LicenseStatus = "REVOKED"
	LicenseStatusSuspended         LicenseStatus = "SUSPENDED"
	LicenseStatusRenewalInProgress LicenseStatus = "RENEWAL_IN_PROGRESS"
)

var AllLicenseStatus = []LicenseStatus{
	LicenseStatusActive,
	LicenseStatusPending,
	LicenseStatusExpired,
	LicenseStatusRevoked,
	LicenseStatusSuspended,
	LicenseStatusRenewalInProgress,
}

func (e LicenseStatus) IsValid() bool {
	switch e {
	case LicenseStatusActive, LicenseStatusPending, LicenseStatusExpired, LicenseStatusRevoked, LicenseStatusSuspended, LicenseStatusRenewalInProgress:
		return true
	}
	return false
}

func (e LicenseStatus) String() string {
	return string(e)
}

func (e *LicenseStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LicenseStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LicenseStatus", str)
	}
	return nil
}

func (e LicenseStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LicenseStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LicenseStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type LicenseType string

const (
	LicenseTypeCultivation    LicenseType = "CULTIVATION"
	LicenseTypeManufacturing  LicenseType = "MANUFACTURING"
	LicenseTypeDistribution   LicenseType = "DISTRIBUTION"
	LicenseTypeRetail         LicenseType = "RETAIL"
	LicenseTypeDelivery       LicenseType = "DELIVERY"
	LicenseTypeTesting        LicenseType = "TESTING"
	LicenseTypeMicrobusiness  LicenseType = "MICROBUSINESS"
	LicenseTypeResearch       LicenseType = "RESEARCH"
	LicenseTypeTransportation LicenseType = "TRANSPORTATION"
	LicenseTypeNursery        LicenseType = "NURSERY"
)

var AllLicenseType = []LicenseType{
	LicenseTypeCultivation,
	LicenseTypeManufacturing,
	LicenseTypeDistribution,
	LicenseTypeRetail,
	LicenseTypeDelivery,
	LicenseTypeTesting,
	LicenseTypeMicrobusiness,
	LicenseTypeResearch,
	LicenseTypeTransportation,
	LicenseTypeNursery,
}

func (e LicenseType) IsValid() bool {
	switch e {
	case LicenseTypeCultivation, LicenseTypeManufacturing, LicenseTypeDistribution, LicenseTypeRetail, LicenseTypeDelivery, LicenseTypeTesting, LicenseTypeMicrobusiness, LicenseTypeResearch, LicenseTypeTransportation, LicenseTypeNursery:
		return true
	}
	return false
}

func (e LicenseType) String() string {
	return string(e)
}

func (e *LicenseType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LicenseType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LicenseType", str)
	}
	return nil
}

func (e LicenseType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LicenseType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LicenseType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type NotificationType string

const (
	NotificationTypeLicenseExpiring  NotificationType = "LICENSE_EXPIRING"
	NotificationTypeRenewalDue       NotificationType = "RENEWAL_DUE"
	NotificationTypeComplianceIssue  NotificationType = "COMPLIANCE_ISSUE"
	NotificationTypeDocumentRequired NotificationType = "DOCUMENT_REQUIRED"
	NotificationTypeRegulationUpdate NotificationType = "REGULATION_UPDATE"
)

var AllNotificationType = []NotificationType{
	NotificationTypeLicenseExpiring,
	NotificationTypeRenewalDue,
	NotificationTypeComplianceIssue,
	NotificationTypeDocumentRequired,
	NotificationTypeRegulationUpdate,
}

func (e NotificationType) IsValid() bool {
	switch e {
	case NotificationTypeLicenseExpiring, NotificationTypeRenewalDue, NotificationTypeComplianceIssue, NotificationTypeDocumentRequired, NotificationTypeRegulationUpdate:
		return true
	}
	return false
}

func (e NotificationType) String() string {
	return string(e)
}

func (e *NotificationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationType", str)
	}
	return nil
}

func (e NotificationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NotificationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NotificationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type RegulationCategory string

const (
	RegulationCategoryLicensing      RegulationCategory = "LICENSING"
	RegulationCategoryTesting        RegulationCategory = "TESTING"
	RegulationCategoryPackaging      RegulationCategory = "PACKAGING"
	RegulationCategoryLabeling       RegulationCategory = "LABELING"
	RegulationCategoryTracking       RegulationCategory = "TRACKING"
	RegulationCategorySecurity       RegulationCategory = "SECURITY"
	RegulationCategoryTransportation RegulationCategory = "TRANSPORTATION"
	RegulationCategoryAdvertising    RegulationCategory = "ADVERTISING"
	RegulationCategoryTaxation       RegulationCategory = "TAXATION"
)

var AllRegulationCategory = []RegulationCategory{
	RegulationCategoryLicensing,
	RegulationCategoryTesting,
	RegulationCategoryPackaging,
	RegulationCategoryLabeling,
	RegulationCategoryTracking,
	RegulationCategorySecurity,
	RegulationCategoryTransportation,
	RegulationCategoryAdvertising,
	RegulationCategoryTaxation,
}

func (e RegulationCategory) IsValid() bool {
	switch e {
	case RegulationCategoryLicensing, RegulationCategoryTesting, RegulationCategoryPackaging, RegulationCategoryLabeling, RegulationCategoryTracking, RegulationCategorySecurity, RegulationCategoryTransportation, RegulationCategoryAdvertising, RegulationCategoryTaxation:
		return true
	}
	return false
}

func (e RegulationCategory) String() string {
	return string(e)
}

func (e *RegulationCategory) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RegulationCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RegulationCategory", str)
	}
	return nil
}

func (e RegulationCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RegulationCategory) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RegulationCategory) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type UserRole string

const (
	UserRoleAdmin             UserRole = "ADMIN"
	UserRoleBusinessOwner     UserRole = "BUSINESS_OWNER"
	UserRoleComplianceManager UserRole = "COMPLIANCE_MANAGER"
	UserRoleEmployee          UserRole = "EMPLOYEE"
)

var AllUserRole = []UserRole{
	UserRoleAdmin,
	UserRoleBusinessOwner,
	UserRoleComplianceManager,
	UserRoleEmployee,
}

func (e UserRole) IsValid() bool {
	switch e {
	case UserRoleAdmin, UserRoleBusinessOwner, UserRoleComplianceManager, UserRoleEmployee:
		return true
	}
	return false
}

func (e UserRole) String() string {
	return string(e)
}

func (e *UserRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRole", str)
	}
	return nil
}

func (e UserRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UserRole) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UserRole) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
