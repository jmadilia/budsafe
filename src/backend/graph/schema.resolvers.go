package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"budsafe/backend/auth"
	"budsafe/backend/graph/generated"
	"budsafe/backend/graph/model"
	"context"
	"database/sql"
	"fmt"
	"log"
	"time"
)

// ComplianceCheckLicense is the resolver for the complianceCheckLicense field.
func (r *complianceCheckResolver) ComplianceCheckLicense(ctx context.Context, obj *model.ComplianceCheck) (*model.License, error) {
	var license model.License
	err := r.DB.Get(&license, `
		SELECT id, business_id, jurisdiction_id, location_id, 
		       license_number, type, status, issued_date::text, 
		       expiration_date::text, renewal_date::text, fee_amount, 
		       notes, created_at::text, updated_at::text 
		FROM licenses 
		WHERE id = $1
	`, obj.LicenseID)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("license with id %s not found", obj.LicenseID)
		}
		return nil, fmt.Errorf("failed to get license: %v", err)
	}
	return &license, nil
}

// ComplianceCheckUser is the resolver for the ComplianceCheckUser field.
func (r *complianceCheckResolver) ComplianceCheckUser(ctx context.Context, obj *model.ComplianceCheck) (*model.User, error) {
	var user model.User
	var createdAt, updatedAt sql.NullString

	if obj.UserID == nil {
		return nil, nil
	}

	err := r.DB.QueryRow(`
		SELECT id, email, first_name, last_name, role, created_at, updated_at
		FROM users
		WHERE id = $1
	`, obj.UserID).Scan(
		&user.ID,
		&user.Email,
		&user.FirstName,
		&user.LastName,
		&user.Role,
		&createdAt,
		&updatedAt,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user with id %v not found", obj.UserID)
		}
		return nil, fmt.Errorf("failed to get user: %v", err)
	}

	if createdAt.Valid {
		user.CreatedAt = createdAt.String
	}
	if updatedAt.Valid {
		user.UpdatedAt = &updatedAt.String
	}

	return &user, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.User, error) {
	// Get the authenticated user from the context.
	authUser := auth.ForContext(ctx)
	if authUser == nil {
		return nil, fmt.Errorf("access denied: user not authenticated")
	}

	// --- TEMPORARY DEBUGGING LINE ---
	// This will print the exact value and type of the role being sent to the query.
	log.Printf("DEBUG: Attempting to insert role. Value: '%s', Type: %T", input.Role, input.Role)
	// --- END DEBUGGING ---

	// Now proceed with the user creation logic...
	query := `
		INSERT INTO users (id, email, first_name, last_name, role, firebase_uid, created_at, updated_at)
		VALUES (gen_random_uuid(), $1, $2, $3, $4, $5, NOW(), NOW())
		RETURNING *`

	var user model.User
	err := r.DB.GetContext(ctx, &user, query, authUser.Email, input.FirstName, input.LastName, string(input.Role), authUser.UID)
	if err != nil {
		return nil, fmt.Errorf("failed to create user profile: %w", err)
	}

	return &user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUserInput) (*model.User, error) {
	panic(fmt.Errorf("not implemented: UpdateUser - updateUser"))
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteUser - deleteUser"))
}

// CreateBusiness is the resolver for the createBusiness field.
func (r *mutationResolver) CreateBusiness(ctx context.Context, input model.CreateBusinessInput) (*model.Business, error) {
	panic(fmt.Errorf("not implemented: CreateBusiness - createBusiness"))
}

// UpdateBusiness is the resolver for the updateBusiness field.
func (r *mutationResolver) UpdateBusiness(ctx context.Context, id string, input model.UpdateBusinessInput) (*model.Business, error) {
	panic(fmt.Errorf("not implemented: UpdateBusiness - updateBusiness"))
}

// DeleteBusiness is the resolver for the deleteBusiness field.
func (r *mutationResolver) DeleteBusiness(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteBusiness - deleteBusiness"))
}

// CreateLicense is the resolver for the createLicense field.
func (r *mutationResolver) CreateLicense(ctx context.Context, input model.CreateLicenseInput) (*model.License, error) {
	panic(fmt.Errorf("not implemented: CreateLicense - createLicense"))
}

// UpdateLicense is the resolver for the updateLicense field.
func (r *mutationResolver) UpdateLicense(ctx context.Context, id string, input model.UpdateLicenseInput) (*model.License, error) {
	panic(fmt.Errorf("not implemented: UpdateLicense - updateLicense"))
}

// DeleteLicense is the resolver for the deleteLicense field.
func (r *mutationResolver) DeleteLicense(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteLicense - deleteLicense"))
}

// CreateLocation is the resolver for the createLocation field.
func (r *mutationResolver) CreateLocation(ctx context.Context, input model.CreateLocationInput) (*model.Location, error) {
	panic(fmt.Errorf("not implemented: CreateLocation - createLocation"))
}

// UpdateLocation is the resolver for the updateLocation field.
func (r *mutationResolver) UpdateLocation(ctx context.Context, id string, input model.UpdateLocationInput) (*model.Location, error) {
	panic(fmt.Errorf("not implemented: UpdateLocation - updateLocation"))
}

// DeleteLocation is the resolver for the deleteLocation field.
func (r *mutationResolver) DeleteLocation(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteLocation - deleteLocation"))
}

// CreateComplianceCheck is the resolver for the createComplianceCheck field.
func (r *mutationResolver) CreateComplianceCheck(ctx context.Context, input model.CreateComplianceCheckInput) (*model.ComplianceCheck, error) {
	panic(fmt.Errorf("not implemented: CreateComplianceCheck - createComplianceCheck"))
}

// UpdateComplianceCheck is the resolver for the updateComplianceCheck field.
func (r *mutationResolver) UpdateComplianceCheck(ctx context.Context, id string, input model.UpdateComplianceCheckInput) (*model.ComplianceCheck, error) {
	panic(fmt.Errorf("not implemented: UpdateComplianceCheck - updateComplianceCheck"))
}

// DeleteComplianceCheck is the resolver for the deleteComplianceCheck field.
func (r *mutationResolver) DeleteComplianceCheck(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteComplianceCheck - deleteComplianceCheck"))
}

// CreateRenewalRequirement is the resolver for the createRenewalRequirement field.
func (r *mutationResolver) CreateRenewalRequirement(ctx context.Context, input model.CreateRenewalRequirementInput) (*model.RenewalRequirement, error) {
	panic(fmt.Errorf("not implemented: CreateRenewalRequirement - createRenewalRequirement"))
}

// UpdateRenewalRequirement is the resolver for the updateRenewalRequirement field.
func (r *mutationResolver) UpdateRenewalRequirement(ctx context.Context, id string, input model.UpdateRenewalRequirementInput) (*model.RenewalRequirement, error) {
	panic(fmt.Errorf("not implemented: UpdateRenewalRequirement - updateRenewalRequirement"))
}

// CompleteRenewalRequirement is the resolver for the completeRenewalRequirement field.
func (r *mutationResolver) CompleteRenewalRequirement(ctx context.Context, id string) (*model.RenewalRequirement, error) {
	panic(fmt.Errorf("not implemented: CompleteRenewalRequirement - completeRenewalRequirement"))
}

// CreateDocument is the resolver for the createDocument field.
func (r *mutationResolver) CreateDocument(ctx context.Context, input model.CreateDocumentInput) (*model.Document, error) {
	panic(fmt.Errorf("not implemented: CreateDocument - createDocument"))
}

// DeleteDocument is the resolver for the deleteDocument field.
func (r *mutationResolver) DeleteDocument(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteDocument - deleteDocument"))
}

// MarkNotificationAsRead is the resolver for the markNotificationAsRead field.
func (r *mutationResolver) MarkNotificationAsRead(ctx context.Context, id string) (*model.Notification, error) {
	panic(fmt.Errorf("not implemented: MarkNotificationAsRead - markNotificationAsRead"))
}

// MarkAllNotificationsAsRead is the resolver for the markAllNotificationsAsRead field.
func (r *mutationResolver) MarkAllNotificationsAsRead(ctx context.Context, userID string) (bool, error) {
	panic(fmt.Errorf("not implemented: MarkAllNotificationsAsRead - markAllNotificationsAsRead"))
}

// NotificationUser is the resolver for the notificationUser field.
func (r *notificationResolver) NotificationUser(ctx context.Context, obj *model.Notification) (*model.User, error) {
	var user model.User
	var createdAt, updatedAt sql.NullString

	err := r.DB.QueryRow(`
		SELECT id, email, first_name, last_name, role, created_at, updated_at
		FROM users
		WHERE id = $1
	`, obj.UserID).Scan(
		&user.ID,
		&user.Email,
		&user.FirstName,
		&user.LastName,
		&user.Role,
		&createdAt,
		&updatedAt,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user with id %s not found", obj.UserID)
		}
		return nil, fmt.Errorf("failed to get user: %v", err)
	}

	if createdAt.Valid {
		user.CreatedAt = createdAt.String
	}
	if updatedAt.Valid {
		user.UpdatedAt = &updatedAt.String
	}

	return &user, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// In a real app, you'd get the user ID from authentication context
	// For now, return the first user
	var user model.User
	err := r.DB.Get(&user, `
		SELECT id, email, first_name, last_name, role, 
		       firebase_uid, created_at::text, updated_at::text 
		FROM users 
		LIMIT 1
	`)
	if err != nil {
		return nil, fmt.Errorf("failed to get current user: %v", err)
	}
	return &user, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	var user model.User
	var createdAt, updatedAt sql.NullString

	err := r.DB.QueryRow(`
		SELECT id, email, first_name, last_name, role, created_at, updated_at
		FROM users
		WHERE id = $1
	`, id).Scan(
		&user.ID,
		&user.Email,
		&user.FirstName,
		&user.LastName,
		&user.Role,
		&createdAt,
		&updatedAt,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user with id %s not found", id)
		}
		return nil, fmt.Errorf("failed to get user: %v", err)
	}

	if createdAt.Valid {
		user.CreatedAt = createdAt.String
	}
	if updatedAt.Valid {
		user.UpdatedAt = &updatedAt.String
	}

	return &user, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	var users []*model.User

	query := `
		SELECT 
			id,
			email,
			first_name,
			last_name,
			role,
			created_at
		FROM users
		ORDER BY created_at DESC
	`

	rows, err := r.DB.Query(query)
	if err != nil {
		return nil, fmt.Errorf("failed to query users: %w", err)
	}
	defer rows.Close()

	for rows.Next() {
		var user model.User
		var createdAt time.Time

		err := rows.Scan(
			&user.ID,
			&user.Email,
			&user.FirstName,
			&user.LastName,
			&user.Role,
			&createdAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan user: %w", err)
		}

		user.CreatedAt = createdAt.Format(time.RFC3339)
		users = append(users, &user)
	}

	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating users: %w", err)
	}

	return users, nil
}

// Business is the resolver for the business field.
func (r *queryResolver) Business(ctx context.Context, id string) (*model.Business, error) {
	var business model.Business
	var createdAt, updatedAt sql.NullString

	err := r.DB.QueryRow(`
		SELECT id, name, type, description, owner_id, created_at::text, updated_at::text 
		FROM businesses 
		WHERE id = $1
	`, id).Scan(
		&business.ID,
		&business.Name,
		&business.Type,
		&business.Description,
		&business.OwnerID,
		&createdAt,
		&updatedAt,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("business with id %s not found", id)
		}
		return nil, fmt.Errorf("failed to get business: %v", err)
	}

	if createdAt.Valid {
		business.CreatedAt = createdAt.String
	}
	if updatedAt.Valid {
		business.UpdatedAt = &updatedAt.String
	}

	return &business, nil
}

// Businesses is the resolver for the businesses field.
func (r *queryResolver) Businesses(ctx context.Context, filter *model.BusinessFilter) ([]*model.Business, error) {
	query := `
		SELECT id, name, type, description, owner_id, created_at::text, updated_at::text 
		FROM businesses
	`
	args := []interface{}{}

	if filter != nil && filter.Type != nil {
		query += " WHERE type = $1"
		args = append(args, *filter.Type)
	}

	query += " ORDER BY created_at DESC"

	var businesses []*model.Business
	err := r.DB.Select(&businesses, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to get businesses: %v", err)
	}
	return businesses, nil
}

// License is the resolver for the license field.
func (r *queryResolver) License(ctx context.Context, id string) (*model.License, error) {
	var license model.License
	err := r.DB.Get(&license, `
		SELECT id, business_id, jurisdiction_id, location_id, 
		       license_number, type, status, issued_date::text, 
		       expiration_date::text, renewal_date::text, fee_amount, 
		       notes, created_at::text, updated_at::text 
		FROM licenses 
		WHERE id = $1
	`, id)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("license with id %s not found", id)
		}
		return nil, fmt.Errorf("failed to get license: %v", err)
	}
	return &license, nil
}

// Licenses is the resolver for the licenses field.
func (r *queryResolver) Licenses(ctx context.Context, filter *model.License) ([]*model.License, error) {
	query := `
		SELECT id, business_id, jurisdiction_id, location_id, 
		       license_number, type, status, issued_date::text, 
		       expiration_date::text, renewal_date::text, fee_amount, 
		       notes, created_at::text, updated_at::text
		FROM licenses
		ORDER BY created_at DESC
	`

	rows, err := r.DB.Query(query)
	if err != nil {
		return nil, fmt.Errorf("failed to query licenses: %w", err)
	}
	defer rows.Close()

	var licenses []*model.License
	for rows.Next() {
		license, err := scanLicense(rows)
		if err != nil {
			return nil, fmt.Errorf("failed to scan license: %w", err)
		}
		licenses = append(licenses, license)
	}

	return licenses, nil
}

// ExpiringLicenses is the resolver for the expiringLicenses field.
func (r *queryResolver) ExpiringLicenses(ctx context.Context, days int) ([]*model.License, error) {
	var licenses []*model.License
	err := r.DB.Select(&licenses, `
    SELECT id, business_id, jurisdiction_id, location_id, 
           license_number, type, status, issued_date::text, 
           expiration_date::text, renewal_date::text, fee_amount, 
           notes, created_at::text, updated_at::text 
    FROM licenses 
    WHERE expiration_date <= CURRENT_DATE + ($1 || ' days')::interval
      AND status IN ('ACTIVE', 'EXPIRING')
    ORDER BY expiration_date ASC
`, days)
	if err != nil {
		return nil, fmt.Errorf("failed to get expiring licenses: %v", err)
	}
	return licenses, nil
}

// Jurisdiction is the resolver for the jurisdiction field.
func (r *queryResolver) Jurisdiction(ctx context.Context, id string) (*model.Jurisdiction, error) {
	row := r.DB.QueryRow(`
		SELECT id, name, type, country, regulatory_body, regulatory_website, license_types, created_at::text, updated_at::text 
		FROM jurisdictions 
		WHERE id = $1
	`, id)
	return scanJurisdiction(row)
}

// Jurisdictions is the resolver for the jurisdictions field.
func (r *queryResolver) Jurisdictions(ctx context.Context) ([]*model.Jurisdiction, error) {
	rows, err := r.DB.Query(`
		SELECT id, name, type, country, regulatory_body, regulatory_website, license_types, created_at::text, updated_at::text 
		FROM jurisdictions 
		ORDER BY name ASC
	`)
	if err != nil {
		return nil, fmt.Errorf("failed to get jurisdictions: %v", err)
	}
	defer rows.Close()

	var jurisdictions []*model.Jurisdiction
	for rows.Next() {
		jurisdiction, err := scanJurisdiction(rows)
		if err != nil {
			return nil, fmt.Errorf("failed to scan jurisdiction: %v", err)
		}
		jurisdictions = append(jurisdictions, jurisdiction)
	}

	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating jurisdictions: %v", err)
	}

	return jurisdictions, nil
}

// ComplianceChecks is the resolver for the complianceChecks field.
func (r *queryResolver) ComplianceChecks(ctx context.Context, licenseID string) ([]*model.ComplianceCheck, error) {
	query := `
		SELECT 
		    id, 
		    license_id, 
		    check_type,
		    status, 
		    checked_at,
		    next_check_date,
		    notes, 
		    checked_by_id,
		    created_at, 
		    updated_at 
		FROM compliance_checks 
		WHERE license_id = $1
		ORDER BY next_check_date DESC
	`

	var checks []*model.ComplianceCheck

	err := r.DB.SelectContext(ctx, &checks, query, licenseID)
	if err != nil {
		fmt.Printf("Error querying compliance checks for licenseID %s: %v\n", licenseID, err)
		return nil, fmt.Errorf("failed to query compliance checks: %v", err)
	}

	// Defensive: Remove any compliance checks with empty or obviously invalid LicenseID
	validChecks := make([]*model.ComplianceCheck, 0, len(checks))
	for _, check := range checks {
		if check.LicenseID != "" {
			validChecks = append(validChecks, check)
		} else {
			fmt.Printf("Skipping ComplianceCheck with empty LicenseID: %+v\n", check)
		}
	}

	return validChecks, nil
}

// ComplianceStatus is the resolver for the complianceStatus field.
func (r *queryResolver) ComplianceStatus(ctx context.Context, businessID string) (*model.ComplianceStatusSummary, error) {
	summary := &model.ComplianceStatusSummary{
		BusinessID: businessID,
	}

	// Get compliance counts for all licenses of this business
	err := r.DB.Get(summary, `
		SELECT 
			COUNT(CASE WHEN cc.status = 'COMPLIANT' THEN 1 END) as compliant_count,
			COUNT(CASE WHEN cc.status = 'NON_COMPLIANT' THEN 1 END) as non_compliant_count,
			COUNT(CASE WHEN cc.status = 'PENDING_REVIEW' THEN 1 END) as pending_count,
			COUNT(CASE WHEN cc.status = 'NEEDS_ATTENTION' THEN 1 END) as attention_count
		FROM compliance_checks cc
		JOIN licenses l ON cc.license_id = l.id
		WHERE l.business_id = $1
	`, businessID)
	if err != nil {
		return nil, fmt.Errorf("failed to get compliance status: %v", err)
	}

	// Determine overall status
	if summary.NonCompliantCount > 0 || summary.AttentionCount > 0 {
		summary.OverallStatus = model.ComplianceStatusNonCompliant
	} else if summary.PendingCount > 0 {
		summary.OverallStatus = model.ComplianceStatusPendingReview
	} else {
		summary.OverallStatus = model.ComplianceStatusCompliant
	}

	return summary, nil
}

// Notifications is the resolver for the notifications field.
func (r *queryResolver) Notifications(ctx context.Context, userID string) ([]*model.Notification, error) {
	var notifications []*model.Notification
	err := r.DB.Select(&notifications, `
		SELECT id, user_id, title, message, type, is_read, 
		       related_entity_id, related_entity_type, created_at::text 
		FROM notifications 
		WHERE user_id = $1
		ORDER BY created_at DESC
		LIMIT 50
	`, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get notifications: %v", err)
	}
	return notifications, nil
}

// DashboardSummary is the resolver for the dashboardSummary field.
func (r *queryResolver) DashboardSummary(ctx context.Context, businessID string) (*model.DashboardSummary, error) {
	summary := &model.DashboardSummary{
		BusinessID: businessID,
	}

	// Get active licenses count
	err := r.DB.Get(&summary.ActiveLicenses, `
		SELECT COUNT(*) FROM licenses WHERE business_id = $1 AND status = 'ACTIVE'
	`, businessID)
	if err != nil {
		return nil, fmt.Errorf("failed to get active licenses count: %v", err)
	}

	// Get expiring licenses count (within 30 days)
	err = r.DB.Get(&summary.ExpiringLicenses, `
		SELECT COUNT(*) FROM licenses 
		WHERE business_id = $1 
		  AND expiration_date <= CURRENT_DATE + INTERVAL '30 days'
		  AND status IN ('ACTIVE', 'EXPIRING')
	`, businessID)
	if err != nil {
		return nil, fmt.Errorf("failed to get expiring licenses count: %v", err)
	}

	// Get compliance issues count
	err = r.DB.Get(&summary.ComplianceIssues, `
		SELECT COUNT(*) FROM compliance_checks cc
		JOIN licenses l ON cc.license_id = l.id
		WHERE l.business_id = $1 AND cc.status IN ('NON_COMPLIANT', 'NEEDS_ATTENTION')
	`, businessID)
	if err != nil {
		return nil, fmt.Errorf("failed to get compliance issues count: %v", err)
	}

	// Get upcoming renewals count (within 30 days)
	err = r.DB.Get(&summary.UpcomingRenewals, `
		SELECT COUNT(*) FROM renewal_requirements rr
		JOIN licenses l ON rr.license_id = l.id
		WHERE l.business_id = $1 
		  AND rr.due_date <= CURRENT_DATE + INTERVAL '30 days'
		  AND rr.completed_at IS NULL
	`, businessID)
	if err != nil {
		return nil, fmt.Errorf("failed to get upcoming renewals count: %v", err)
	}

	// Get recent notifications
	err = r.DB.Select(&summary.RecentNotifications, `
		SELECT n.id, n.user_id, n.title, n.message, n.type, n.is_read, 
		       n.related_entity_id, n.related_entity_type, n.created_at::text 
		FROM notifications n
		JOIN users u ON n.user_id = u.id
		JOIN businesses b ON u.id = b.owner_id OR EXISTS (
			SELECT 1 FROM licenses l WHERE l.business_id = b.id AND l.business_id = $1
		)
		WHERE b.id = $1
		ORDER BY n.created_at DESC
		LIMIT 5
	`, businessID)
	if err != nil {
		return nil, fmt.Errorf("failed to get recent notifications: %v", err)
	}

	return summary, nil
}

// Hello is the resolver for the hello field.
func (r *queryResolver) Hello(ctx context.Context) (string, error) {
	return "Hello, BudSafe User with Real Database!", nil
}

// NotificationAdded is the resolver for the notificationAdded field.
func (r *subscriptionResolver) NotificationAdded(ctx context.Context, userID string) (<-chan *model.Notification, error) {
	panic(fmt.Errorf("not implemented: NotificationAdded - notificationAdded"))
}

// LicenseStatusChanged is the resolver for the licenseStatusChanged field.
func (r *subscriptionResolver) LicenseStatusChanged(ctx context.Context, businessID *string) (<-chan *model.License, error) {
	panic(fmt.Errorf("not implemented: LicenseStatusChanged - licenseStatusChanged"))
}

// ComplianceStatusChanged is the resolver for the complianceStatusChanged field.
func (r *subscriptionResolver) ComplianceStatusChanged(ctx context.Context, businessID *string) (<-chan *model.ComplianceCheck, error) {
	panic(fmt.Errorf("not implemented: ComplianceStatusChanged - complianceStatusChanged"))
}

// ExpiringBefore is the resolver for the expiringBefore field.
func (r *licenseFilterResolver) ExpiringBefore(ctx context.Context, obj *model.License, data *string) error {
	panic(fmt.Errorf("not implemented: ExpiringBefore - expiringBefore"))
}

// ComplianceCheck returns generated.ComplianceCheckResolver implementation.
func (r *Resolver) ComplianceCheck() generated.ComplianceCheckResolver {
	return &complianceCheckResolver{r}
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Notification returns generated.NotificationResolver implementation.
func (r *Resolver) Notification() generated.NotificationResolver { return &notificationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// LicenseFilter returns generated.LicenseFilterResolver implementation.
func (r *Resolver) LicenseFilter() generated.LicenseFilterResolver { return &licenseFilterResolver{r} }

type complianceCheckResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type notificationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type licenseFilterResolver struct{ *Resolver }
